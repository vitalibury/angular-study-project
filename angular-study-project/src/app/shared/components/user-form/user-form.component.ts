import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';
import { AbstractControl, AsyncValidatorFn, FormArray, FormControl, FormGroup, ValidationErrors, Validators } from '@angular/forms';
import { debounceTime, delay, first, map, merge, Observable, Subscription, tap } from 'rxjs';
import { IUser, UsersService } from '../../../user';


@Component({
  selector: 'app-user-form',
  templateUrl: './user-form.component.html',
  styleUrls: ['./user-form.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class UserFormComponent implements OnInit, OnDestroy, OnChanges {

  subscription: Subscription = new Subscription();

  @Input() user: IUser;

  form: FormGroup;
  editingUserEmail: string;
  formValueSeries = [];
  changedFields = {};
  isLoading = false;

  constructor(
    private usersService: UsersService,
    private cdr: ChangeDetectorRef
  ) { }

  ngOnInit(): void {
    this.form = new FormGroup({
      firstName: new FormControl('', Validators.required),
      lastName: new FormControl('', Validators.required),
      age: new FormControl('', [Validators.required, Validators.min(15), Validators.max(100)]),
      email: new FormControl(
        '',
        [Validators.required, , Validators.email, Validators.pattern(/@gmail.com\b/)],
        [this.existEmailAsyncValidator()]
      ),
      company: new FormControl('', Validators.maxLength(35)),
      department: new FormControl('', Validators.minLength(6)),
      // photo: new FormControl(null),
      gender: new FormControl('', Validators.required)
    });

    this.subscription.add(merge(    // если отключать подписку и влюкчать то перенести это в он инит (AfterViewInit)
      this.form.get('firstName').valueChanges,
      this.form.get('lastName').valueChanges
    )
      .subscribe(() => {
        this.setAutoGeneratedEmail();
        this.form.get('email').markAsTouched();
      }));

    this.subscription.add(this.form.valueChanges.pipe(
      debounceTime(500),
      tap(formValue => {
        if (this.formValueSeries.length) {
          const lastFormValue = this.formValueSeries[this.formValueSeries.length - 1];
          if (!this.isFormsValueEqual(lastFormValue, formValue)) {
            this.formValueSeries.push(formValue);
          }
        }
        else {
          this.formValueSeries.push(formValue);
        }
      }),
    ).subscribe());
  }

  ngOnChanges(changes: SimpleChanges): void {
    // if (this.user === null) {        // перестает отрабатывать patchValue для адресов
    //   this.isLoading = true;
    // } else {
    //   this.isLoading = false;
    // }
    if (changes && changes['user'].currentValue) {
      // отключать подписку с merge'm не требуется, почему работает без этого?
      const user = changes['user'].currentValue;
      this.editingUserEmail = user.email;
      this.form.patchValue(user);
      this.formValueSeries = [this.form.value];
    }

  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }



  isFormsValueEqual(firstForm: IUser, secondForm: IUser): boolean {
    for (const key in firstForm) {
      if (firstForm.hasOwnProperty(key)) {
        if (typeof(firstForm[key]) !== 'object' && (firstForm[key] !== secondForm[key])) {
          console.log(firstForm[key], secondForm[key])
          this.changedFields[key] = secondForm[key] ? secondForm[key] : '_';
          this.form.get(key).updateValueAndValidity();
          this.form.get(key).markAsTouched();
          return false;
        }
      }
    }
    return true;
  }

  markFormAsChecked(): void {
    this.form.markAllAsTouched();
    this.cdr.detectChanges();
  }

  checkFormValid(controlName: String): Boolean {
    const control = this.form.controls[`${controlName}`];
    const hasError = control.invalid && (control.dirty || control.touched);
    return hasError;
  }

  existEmailAsyncValidator(): AsyncValidatorFn {
    return (control: AbstractControl): Observable<ValidationErrors> => {
      return this.usersService.isEmailExist(control.value).pipe(map(
        existence => (existence && this.form.get('email').value !== this.editingUserEmail) ? { emailExist: true } : null  // перепроверить правильное ли условие
      ), delay(1000));
    }
  }

  addControl(addressesArrayForm: FormArray): void {
    this.form.addControl('addresses', addressesArrayForm);
  }

  setAutoGeneratedEmail(): void {
    const generatedEmail = `${this.form.get('firstName').value}${this.form.get('lastName').value}@gmail.com`;
    this.form.get('email').setValue(generatedEmail);
  }

}
